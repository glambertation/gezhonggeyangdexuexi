## 精通比特币

* ch4 加密技术
  * 公钥和私钥
    * 有了私钥，我们就可以使用椭圆曲线乘法这个单向加密函数产生一个公钥（K）。有了公钥（K），我们就可以使 用一个单向加密哈希函数生成比特币地址（A）
    * 私钥
      * 随机生成256位私钥/64位16进制
    * 公钥
      * 通过椭圆曲线乘法可以从私钥计算得到公钥，这是不可逆转的过程：K = k * G 
      * 椭圆曲线[https://www.cnblogs.com/qcblog/p/8998045.html]
    * 比特币地址
      * 在交易中，比特币地址通常以收款方出现。如果把比特币交易比作一张支票，比特币地址就是收款人
      * 公钥经过hash（SHA256和RIPEMD160），再进行Base58Check校验编码，生成地址
      * Base58是Base64编码格式的子集，同样使用大小写字母和10个数字，但舍弃了一些容易错 读和在特定字体中容易混淆的字符。
  * 秘钥格式
    * 十六进制和原始的二进制格式用在软件的内部，很少展示给用户看。WIF格式用在钱包之间密钥的输入和输出，也用于代表私钥的二维码（条形码）。
    * 压缩
      * 一个公钥是一个椭圆曲线上的点(x, y)。而椭圆曲线实际是一个数学方程，曲线上的点实际是该方程的一个解
      * 只存储公钥的x坐标，略去y坐标
  * 加密私钥
    * 冷存储
  * 多重地址
    * 虽然任何人都可以将比特币发送到 一个1开头的地址，但比特币只能在通过相应的私钥签名和公钥哈希值后才能消费。

* ch5 钱包
  * 定义
    * 钱包是一个应用程序，为用户提供交互界面。 钱包控制用户访问权限，管理密钥和地址，跟踪余额以及创建和签名交易
    * 从程序员的角度来看，“钱包”是指用于存储和管理用户密钥的数据结构
    * 钱包里只含有钥匙。 “钱币”被记录在比特币网络的区块链中
      * 钱包只包含私钥/公钥对的密钥链
      * 用户用密钥签名交易，从而证明他们拥有交易输出（他们的钱币）。 钱币以交易输出的形式存储在区块链中（通常记为vout或txout）
    * 非确定性钱包
      * 其中每个密钥都是从随机数独立生成的。密钥彼此无关。这种钱包也被称为“Just a Bunch Of Keys（一堆密钥）”，简称JBOK钱包。
        * 这就意味着这个钱包必须被经常性 地备份。每一个密钥都必须备份，否则一旦钱包不可访问时，钱包所控制的资金就付之东流。
        * 这种情况直接与避免地址重复使用的原则相冲突——每个比特币地址只能用一次交易。地址重复使用将多个交易和地址关联在一起，这会减少隐私。
    * 确定性钱包
      * 其中所有的密钥都是从一个主密钥派生出来，这个主密钥即为种子（seed）。该类型钱包中所有密钥都相互关联，如果有原始种子，则可以再次生成全部密钥。
      * 确定性钱包中使用了许多不同的密钥推导方法。最常用的推导方法是使用树状结构，称为分级确定性钱包或HD钱包。
      * 确定性钱包由种子衍生创造。为了便于使用，种子被编码为英文单词，也称为助记词
      * 分层确定性钱包
        * HD钱包
          * HD钱包包含以树状结构衍生的密钥，使得父密钥可以衍生一系列子密钥，每个子密钥又可以衍生出一系列孙密钥，以此类推，无限衍生
          * 优势
            * 第一，树状结构可以被用来表达额外的组织含义。比如当一个特定分支的子密钥被用来接收交易收入并且有另一个分支的子密钥用来负责支付花费。不同分支的密钥都可以被用在企业环境中，这就可以支配不同的分支部门、子公司、具体功能以及会计类别。
            * HD钱包的第二个好处是，用户可以创建一系列公钥，而不需要访问对应的私钥。这样，HD钱包就能用在不安全的服务器上，或者用在接收环境中，它为每个交易发布一个不同的公钥。公共钥匙不需要被预先加载或者提前衍生，而在服务器中不需要可用来支付的私钥。
          * 种子和助记词
            * 由一系列英文单词生成种子是个标准化的方法，这样易于在钱包中转移、导出和导入
            * 使用可互操作的助记词导入和导出种子进行备份和恢复
            * 16进制表示的种子： 0C1E24E5917779D297E14D45F14E1A1A
            * 助记词表示的种子： army van defense carry jealous true garbage claim echo media make crunch
            * 助记码，基于BIP-39
            * HD钱包，基于BIP-32
              * HD钱包从单个根种子（root seed）中创建
            * 技术细节
              * 创建助记词
              * 从助记词生成种子（助记符+盐，2048次hash）
              * 可选密码短语
            * 从种子中创造HD钱包
              * 根种子输入到HMAC-SHA512算法中就可以得到一个可用来创造主私钥(m)（master private key(m) ）和主链代码（a master chain code）的哈希
              * 主私钥（m）之后可以通过使用我们在本章先前看到的那个普通椭圆曲线m * G过程生来成相对应的主公钥（M）
              * 链代码用于从母密钥中创造子密钥的那个函数中引入熵
              * 私有子密钥的衍生
                * 分层确定性钱包使用CKD（child key derivation)函数去从母密钥衍生出子密钥
              * 使用衍生的子密钥
              * 扩展密钥
              * 公共子密钥推导
              * 在网店中使用扩展公钥（xpub）
              * 硬化子密钥的衍生
              * 正常衍生和强化衍生的索引号码
              * HD钱包密钥识别符（路径）
              * HD钱包树状结构的导航
* ch6 交易
  * 比特币系统
    * 根据比特币系统的设计原理，系统中任何其他的部分都是为了确保比特币交易可以被生成、能在比特币网络中得以传播和通过验证，并最终添加入全球比特币交易总账簿（比特币区块链）
    * 比特币交易的本质是数据结构，这些数据结构中含有比特币交易参与者价值转移的相关信息
    * 比特币区块链是一本全球复式记账总账簿，每个比特币交易都是在比特币区块链上的一个公开记录。
  * 交易的输入输出
    * 未花费的交易输出”（unspent transaction outputs）
    * UTXO
      * 找零
    * 交易输出
      * 一定量的比特币，面值为“聪”（satoshis） ，是最小的比特币单位；
      * 确定花费输出所需条件的加密难题（cryptographic puzzle）
        * 这个加密难题也被称为锁定脚本(locking script), 见证脚本(witness script), 或脚本公钥 (scriptPubKey)。
      * 交易序列化 - 输出
        * 大多数比特币函数库和架构不会在内部将交易存储为字节流，因为每次需要访问单个字段时，都需要复杂的解析
        * 为了方便和可读性，比特币函数库将交易内部存储在数据结构（通常是面向对象的结构）中。
    * 交易输入
    * 交易费
      * 交易费作为矿工打包（挖矿）一笔交易到下一个区块中的一种激励；同时作为一种抑制因素，通过对每一笔交易收取小额费用来防止对系统的滥用。成功挖到某区块的矿工将得到该区内包含的矿工费， 并将该区块添加至区块链中
      * 高优先级意味着用户支付更高的交易费，但交易可能就会被打包进下一个块中。中低优先级意味着用户支付较低的交易费，但交易可能需要更长时间才能确认。
    * 把交易费加到交易中
      * 如果你忘记了在手动构造的交易中增加找零的输出，系统会把找零当作交易费来处理
      
    * 比特币交易脚本和脚本语言
      * 如今，大多数经比特币网络处理的交易是以“Alice付给Bob”的形式存在，并基于一种称为“P2PKH”（Pay-toPublic-Key-Hash）脚本。但是，比特币交易不局限于“支付给Bob的比特币地址”的脚本。
      * 图灵非完备性
        * 这意味着脚本有限的复杂性和可预见的执行次数
        * 脚本并不是一种通用语言，这些限制确保该语言不被用于创造无限循环或其它类型的逻辑炸弹，这样的炸弹可以植入在一笔交易中，引起针对比特币网络的“拒绝服务”攻击。
      * 去中心化验证
        * 可以预见的是，一个脚本能在任何系统上以相同的方式执行。如果您的系统验证了一个脚本，可以确信的是每一个比特币网络中的其他系统也将验证这个脚本，这意味着一个有效的交易对每个人而言都是有效的，而且每一个人都知道这一点。这种结果可预见性是比特币系统的一项至关重要的良性特征。
      *  脚本构建（锁定与解锁）
        * 比特币的交易验证引擎依赖于两类脚本来验证比特币交易：锁定脚本和解锁脚本。
        * 锁定脚本（条件）
          * 锁定脚本是一个放置在输出上面的花费条件：它指定了今后花费这笔输出必须要满足的条件。
          * 由于锁定脚本往往含有一个公钥或比特币地址（公钥哈希值），在历史上它曾被称为脚本公钥（scriptPubKey）
          * 您还将看到被称为见证脚本（witness script）的锁定脚本（参见[隔离见证]章节），或者更一般地说，它是一个加密难题（cryptographic puzzle）。 这些术语在不同的抽象层次上都意味着同样的东西。
        * 解锁脚本（满足）
          * 解锁脚本是一个“解决”或满足被锁定脚本在一个输出上设定的花费条件的脚本，它将允许输出被消费。
          * 解锁脚本是每一笔比特币交易输入的一部分，而且往往含有一个由用户的比特币钱包（通过用户的私钥）生成的数字签名。
          * 由于解锁脚本常常包含一个数字签名，因此它曾被称作ScriptSig
        * 验证
          * 每一个比特币验证节点会通过同时执行锁定和解锁脚本来验证一笔交易。
          * 每个输入都包含一个解锁脚本，并引用了之前存在的UTXO。 
          * 验证软件将复制解锁脚本，检索输入所引用的UTXO，并从该UTXO复制锁定脚本
          * 然后依次执行解锁和锁定脚本。 如果解锁脚本满足锁定脚本条件，则输入有效（请参阅单独执行解锁和锁定脚本部分）。
          * 所有输入都是独立验证的，作为交易总体验证的一部分。
          * 请注意，UTXO被永久地记录在区块链中，因此是不变的，并且不受在新交易中引用失败的尝试的影响。 只有正确满足输出条件的有效交易才能将输出视为“开销来源”，继而该输出将被从未花费的交易输出集（UTXO set）中删除。
    
    
## btc
 * 比特币系统的底层是一个由多方共同维护，使用密码学保证传输和访问安全，实现数据一致存储、难以篡改、防止抵赖的分布式账本，也称为区块链
 * 中本聪将非对称加密、点对点技术、工作量证明三项关键技术结合在一起，创造了第一个不依赖于中心化机构的点对点电子现金系统，并且在全球大规模部署。
 * 公链
   * 以太坊，eos
 * 私链
   * r3 hyperledger
 * eth 以太坊
   * 了智能合约的概念，用户可编写智能合约的程序并将其部署在区块链上，使得区块链从主要用于记录电子现金转账的“专有账本”，升级为可记录计算状态
（state machine）的“通用账本”，区块链进入可编程时代
   * token
   * 基础设施产业（ 矿机生产、矿池、交易、托管、钱包等
   * 问题 
     * 身份适配
     * 商业适配
     * 数据适配 （但区块链只能保证来自于外部的数据无法篡改，无法保证真实准确。
     * 法律适配 （身份认证问题在法律上将导致责任主体不明，如果利用公有链的合约出现了法律纠纷，无法确立责任主体
 * 技术瓶颈
   * 可扩展性，性能瓶颈 吞吐量；主要是通过发展多样态共识、并行分片方案、二层网络方案及可验证计算来解决和改善
   * 互操作性 不同区块链的互操作，高效链接机制；跨链机制（1、中继/侧链 2、公证人机制 3、哈希锁定）
   * 隐私保护：假名、混币、环签名、Mimblewimble、零知识证明和可信计算解决
   * 安全性： 智能合约安全运行
   * 技术
     * 多样态共识模式 
       * 共识算法用于协调系统中节点的行为和保持数据一致性
       * 共识算法在共识顺序、共识轮次、终局性和节点选择方式等方向的差异，形成多样态发展的态势
       * 例如 PoW 共识效率低，DPoS 去中心化程度较低等，Algorand、DFINITY、VBFT 等都属于混合共识算法
     * 并行分片
       * 区块链系统中每个节点全量处理所有交易，单纯增加节点并不能提升区块链的性能（TPS），反而节点之间达成共识的过程对性能是一个损耗
       * 区块链的分片就是试图让链并行起来，将链分为多个分片链，然后通过一种负载分发机制，把交易分配给不同的分片执行，每个分片链独立运行，有独立的共识机制，通过并行的方案支撑比较强的水平扩展和按需扩展
       * 如何把分片的理论和区块链的安全理论，包括密码经济学设计、激励机制设计，这些融合在一起来实现一个安全可扩展，而且高性能的区块链
         * 网络分片：要求分片的消息只在分片内部网络中传播
         * 交易分片：指不同交易将只在不同的分片中运行，每个分片运行独立的共识算法；
         * 状态分片：要求分片只需要维护分片内部的状态数据而不需要保存其它分片的数据
     * 二层网络
       * 区块链二层网络（Layer2）技术旨在解决区块链扩容问题。区块链本身的容量是受限的，仅靠提高吞吐量很难满足所有的应用需求
       * 实际情况中，不是所有的交易都要在全球范围内达成共识，可以把部分交易以及合约执行只在所需范围内进行共识，以实现扩容的目标。广义的二层网络，
包含了侧链，状态通道等各种将区块链的交易从链上迁移到链下（也可能是别的共识范围更小的链）的技术方案。二层网络设计中，脱离的链上共识的交易与合约如何与链上的共识挂接，保证交易和合约的合法性及安全性是需要解决的问题
         * 证明问题：链上没有全量数据的情况下，链下的交易最终如何给链上提交证明。
         * 裁决和惩罚问题：裁决和执行如何进行以产生链下约束力
         * 监督问题：链下状态的监督
       * 方案
         * 状态通道
         * 多方链下账本托管
         * 侧脸账本
         * 状态账本
     * 隐私性保护 
       * 假名，混币，机密交易，环签名，Mimblewimble，Zero—Knowledge Proof）
   * 可信
     * 一是数据隐私保护
     * 二是可验证计算
     * 可信环境 TEE
     * 同态加密/全同态加密
       * Enc(x)+Enc(y)=Enc(x+y)，就可以说 Enc 对于加法具有同态性。
常见的如 RSA 加密算法和椭圆曲线群都是关于加法同态的
   * 跨链
     * 跨链技术的核心在于让不同的区块链能跨越彼此的障碍，从而在数据和价值的层面进行相互流通
   * 智能合约安全问题
     * 智能合约是一种旨在以信息化方式传播、验证或执行的计算机协议。智能合约允许在没有第三方的情况下进行可信交易，这些交易可追踪且不可逆转。
     * 漏洞类型
       * 编程语言漏洞，基于区块链平台特性的漏洞，业务逻辑的漏洞，合约虚拟机的漏洞
   * 公链治理
     * 一般来说，公有区块链治理生态构成由四种角色组成：区块链协议开发者、矿工、上层应用开发者及用户
       
       
## 电信
* Blockchain 
  * 每个区块包含链上前一个区块内容计算出来的哈希值，修改任何一个区块的任意一个字符都能导致后续计算出来的哈希值和下一个区块记录的不匹配，很容易被别的节点检测出来，只有修改了链上后续所有区块的内容才能保证区块链的完整性
  * 
